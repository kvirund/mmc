I.      КАК ИСПОЛЬЗОВАТЬ ДАННЫЙ ДОКУМЕНТ

Эта справка писалась параллельно с написанием самого клиента, при этом изменения
в коде клиента не всегда отражались в справке. Так что если кто-то обнаружил,
что справка уже не совсем соответвует поведению клиента (а так же при
обнаружении прочих ошибок, в том числе орфографических), просьба писать
на dima@rt.ru. Сам клиент можно взять здесь: http://dima.rt.ru/mmc.dir/

II.     ЛИЦЕНЗИОННОЕ СОГЛАШЕНИЕ.

    Клиент распространяется на тех же условиях, что и интерпретатор Perl. Это
значит что Вы можете выбрать либо GPL, либо Artistic License при модификации
и/или распространении клиента. Авторами и владельцами прав на данный продукт и
документацию к нему являются:
       Михаил Мацнев (программа)
       Дмитрий Ржавин (доументация, тестирование) 

III.    ЧТО ЭТО ТАКОЕ

    Это - клиент для игры в MUD. Если Вы не знаете, что такое MUD, то, скорее
всего, эта программа Вам не нужна.
    Клиент является посредником между пользователем и игровым сервером. Он
получает данные из двух потоков: от сервера и от пользователя. При получении
строки от сервера, клиент проверяет, не является ли эта строка приглашением
сервера (prom ga или аналогичная команда сильно поможет клиенту находить
приглашения), и если является, для ее обработки вызывается специальный триггер.
Если эта строка - не приглашение, клиент просматривает список активных
триггеров, пытаясь применить их к строке. Если триггер применим к этой строке,
выполняется код триггера, строка печатается на экран и обработка этой строки
прекращается (если в примененном триггере не предписано другое поведение, см. п.
VI). Хочу обратить Ваше внимание, что для приглашения вызывается только
специальный триггер, и никакой другой.
    Реакция клиента на пользовательский ввод будет описана в п. V.


IV.     КРАТКОЕ ОПИСАНИЕ КЛИЕНТА

1. Обзор возможностей.
Основные возможности:
    - алиасы
    - определение горячих клавиш
    - приоритетные триггеры с широкими возможностями их настройки и группировки
    - автоматическое определение приглашения сервера и возможность создать
      специальный триггер для его обработки
    - возможность создавать триггер на некоторые события, генерируемые клиентом,
      например триггер на сообщение клиента о наступающем игровом часе
    - встроенный speedwalk
    - возможность просмотра лога (клавишами PageUp и PageDown)
    - встроенный таймер
    - поддержка протокола mccp (Mud Client Compression Protocol)
    - возможность запускать асинхронные потоки вывода
    - наличие строки состояния
    - расширенные возможности редактирования командной строки, включая поиск
      строк и отдельных слов по истории команд и возможность настраиваемого
      дополнения слов из списков.
    - возможность написания файла настроек на языке perl, что позволяет писать
      триггеры любой сложности.

2. Требования к системе.
    - OS UNIX или Win*. Программа тестирована на FreeBSd 4.x, Solaris 8 и на
      Windows 2000/Windows 98.
    - Наличие библиотеки perl версии 5.00503 или выше. (Для Win* эта библиотека
      включена в пакет с клиентом).

3. Установка.
    - Распакуйте поставляемый архив.
    - Перейдите в каталог с файлами программы и посмотрите на его содержимое.
      Если там нет ни одного исполняемого файла, либо выполнение программы mmc
      завершается сообщением об ошибке, наберите:
        ./configure
        make depend
        make
      В результате будет создан выполнимый файл, либо Вам объяснят, почему
      это невозможно. Выполнимый файл должен называться mmc<номер версии>,
      mmc<номер версии>.exe или как-то еще в зависимости от операционной
      системы и желаний автора. В дальнейшем я буду называть его mmc.
    - Скопируйте mmc и, возможно, библиотеку perl, в какой-нибудь из системных
      каталогов (или наберите make install). Добавьте теперь каталог, куда был
      установлен mmc, в $PATH. Если Вы используете tcsh, это делается командой:
        set path = (/where/mmc/lives $path)
      Добавьте ее в конец вашего .tcshrc.
      Если Вы по какой-либо причине используете другой shell, обратитесь к
      документации по нему.
      Под Windows клиент состоит из единственного исполняемого фаила,
      скопируйте его в любое удобное место и запускайте.
    - Запустите программу. Если все хорошо, она должна напечатать что-то типа:
        -:- Loading {/root/.mmc4rc}...
        -:- MMC v4.1.9999 by Mike E. Matsnev
        mmc> 

4. Параметры командной строки и переменные окружения
    -c          - показывать состояние дополнения в строке состояния.
    -f <file>   - сохранять историю команд в отдельный файл.
    -h, -?      - справка по ключам
    -i <path>   - добавить path в список каталогов, в которых клиент будет
                  искать модули, можно указывать несколько раз.
    -k          - показывать в строке состояния коды нажимаемых клавиш. Удобно
                  для настройки горячих клавиш.
    -n          - не показывать состояние соединения в строке состояния.
    -p          - показывать префикс в строке состояния. (см. команду /prefix)
    -r          - не перезаписывать файл настроек при выходе из клиента.
    -s <type>   - местоположение строки состояния. Возможные значения:
                    0   - строка состояния выключена
                    1   - строка состояния над приглашением
                    2   - строка состояния под приглашением (установка по
                          умолчанию).
    <file name> - файл с пользовательскими настройками.

    $MMC  - место хранения файлов клиента по умолчанию.
    $HOME - домашний каталог пользователя. Используется вместо $MMC, если $MMC
            не определена.
    Под Windows, если файл настроек не найден, он создается в той директории,
    где находится исполняемый файл mmc.exe.

5. Встроенный редактор.
    Для редактирования командной строки определены следующие команды:
    <Ctrl>-@    - установить маркер
    <Ctrl>-A    - в начало строки
    <Ctrl>-B    = стрелка влево
    <Ctrl>-E    - в конец строки
    <Ctrl>-F    = стрелка вправо
    <Ctrl>-K    - Удалить в буфер все от текущей позиции курсора до конца строки
    <Ctrl>-N    = стрелка вниз
    <Ctrl>-O    - скопировать в буфер все от текущей позиции курсора до маркера
    <Ctrl>-P    = стрелка вверх
    <Ctrl>-U    - удалить все из командной строки
    <Ctrl>-V    - вставляет в строку указанный далее символ, даже если этот
                  символ непечатный
    <Ctrl>-W    - удалить в буфер все от текущего положения курсора до маркера
    <Ctrl>-X    - поменять местами курсор и маркер
    <Ctrl>-Y    = Ins, вставить из буфера
    <Alt>-/     - поиск слов по истории
    <Alt>-_     - вставить последнее слово предыдущей команды
    <Alt>-backspace - удалить предыдущее слово в буфер
    <Alt>-d     - удалить слово в буфер
    <Alt>-<Del> - удалить слово в буфер
    <Alt>-k     - удалить в буфер все от текущего положения курсора до начала
                  строки
    <Alt>-n     - поиск строки вниз по истории
    <Alt>-p     - поиск строки вверх по истории
    стрелки, Del, Home, End (последние 2 - не у всех ;)
    <Tab>       - контекстно-зависимое добавление по словам. Для его
                  использования нужно сначала создать список слов (например,
                  командой tabadd, см. п. V), и потом, если вы наберете начало
                  одного из этих слов и нажмете <Tab>, клиент сам дополнит это
                  слово. Пример использования - создать список группы (например,
                  триггером) и использовать дополнение для более быстрого набора
                  имен одногруппников для спасения или лечения:
    action {^Your group of ([0-9]+) members consists of:} {/set members ($1+3);/set curr 0;/enable GBUILD} {2000f:CORE}
    action {^\s*(\w*)} {/set last $1;/set curr ($curr+1);/if {$curr > $members} {/disable GBUILD} {/if {$curr > 3} {/tabadd $last}}} {1500f-:GBUILD}
                  Замечание: Для уменьшения спама от таких триггеров я предлагаю
                  выключить подтверждение. Как это сделать рассказано в п. X.
                  Более подробно о настройке дополнения будет рассказано в
                  п. IX.

V.   КОМАНДЫ ПОЛЬЗОВАТЕЛЯ.
Я буду использовать следующие соглашения:
    <текст>     - на этом месте должно стоять что-то, подпадающее под описание
                  внутри угловых скобок.
    [текст]     - параметр, указанный внутри квадратных скобок, можно опускать.
    txt1|txt2   - должно быть либо txt1, либо txt2.
    pattern     - параметр понимается как shell pattern. pattern может содержать
                  символы '*' и '?', если не указаны дополнительные ограничения.
    regexp      - параметр понимается как perl regexp (см. п. VI).
    ==> <текст> - в примерах: клиент послал серверу <текст>

Клиент интерпретирует пользовательский ввод следующим образом:
    1) поиск "горячих кнопок". Предписанные действия выполняются как только
       пользователь нажал соответствующую комбинацию клавиш. (Пример - клавиша
       <Enter>, которая заставляет клиент проинтерпретировать введенный
       пользователем текст). Обработка всего остального пользовательского
       ввода осуществляется только после нажатия <Enter>.
    2) разбор пользовательского ввода. На этом этапе происходит разбиение
       введенной пользователем строки на слова и команды. Вы можете указывать
       несколько команд в одной строке, разделяя их символом ';'. Результат
       будет точно такой же, как если бы эти команды набирались пользователем
       последовательно одна за другой. Единственное ограничение - определенные
       в этой строке команды и алиасы не будут применяться в этой строке, даже
       если определение и использование этой команды или алиаса разделены
       символом ';':
            /alias xxx ZZZ;xxx
            -:- {xxx} aliases {ZZZ}.
            ==> xxx
       Слова (команды, алиасы и их аргументы) разделяются символами <пробел>.
       Если вам необходимо передать символ ';' или <пробел> в команду, перед ним
       надо поставить символ '\'. Сам символ '\' можно передать в команду,
       указав его дважды. Пример: /showme \\\;. Еще один способ передать строку,
       содержащую символы ';', '\' - это указав всю строку в фигурных скобках,
       вот так: /showme {\;}. Все, что указано в фигурных скобках, будет
       передано команде. Пример использования:
            /alias test {/showme $var}
            -:- {test} aliases {/showme $var}.
            /var var FOO
            -:- {var} is now set to {FOO}.
            test
            -:- FOO
            /var var BAR
            -:- {var} is now set to {BAR}.
            test
            -:- BAR
    3) поиск алиасов. Алиасы ищутся только с первого символа введенной
       пользователем команды. Поскольку большинство игровых серверов игнорируют
       пробелы в начале команды, такая схема поиска алиасов позволяет легко
       послать игровому серверу команду, совпадающую с названием алиаса.
       Например:
                alias quit say I'm so stupid doday.
                quit    - пошлет серверу команду say I'm so stupid doday.
                 quit   - пошлет серверу команду  quit
       Если алиас найден, описанная в алиасе замена производится, и полученная
       строка обрабатывается, как будто она только что введена пользователем
       (то есть с п. 2). Пример:
                /alias ZZZ /alias xxx foo\\\;bar\;xxx
        (можно было бы написать и /alias ZZZ {/alias xxx foo\;bar;xxx})
                -:- {ZZZ} aliases {/alias xxx foo\;bar;xxx}.
            сейчас алиас ZZZ только определен, но не выполнен:
                /alias
                -:- Defined aliases:
                -:- {ZZZ}={/alias xxx foo\;bar;xxx}
            теперь мы его выполним:
                ZZZ
                -:- {xxx} aliases {foo;bar}.
                ==> xxx
            при его выполнении был определен новый алиас, но он не был
            применен, так как он определен в той же строке, что и использован.
            Сейчас список алиасов выглядит так:
                /alias
                -:- Defined aliases:
                -:- {xxx}={foo;bar}
                -:- {ZZZ}={/alias xxx foo\;bar;xxx}
            И теперь алиас xxx будет применяться:
                ZZZ
                -:- {xxx} aliases {foo;bar}.
                ==> foo
                ==> bar
        Поскольку алиасы ишутся до пользовательских команд, можно делать даже
        такие алиасы:
            /alias /q /quit
    4) поиск команд в пользовательском вводе. Все команды клиенту (и только они)
       должны начинаться со специальной определяемой последовательности
       символов. По умолчанию, это '/' (без кавычек). Если первым символом
       введенной пользователем команды оказывается '/' (точнее, строка,
       назначенная пользователем, см. команду /char), такая команда понимается
       как команда клиенту. Команды клиенту можно сокращать до любого префикса,
       однозначно определяющего команду.

Встроенные в клиент команды:
    quit    - выход из клиента.
    connect <addr> <port> [<local address>]
            - установить соединение с addr:port с локального адреса local
              address. Если не указан, берется один из адресов машины.  Если
              соединение уже было установлено, оно предварительно закрывается
              без предупреждения.
    dc      - завершить соединение.
    alias   - показать активные алиасы
    alias <pattern>
            - показать алиасы, подпадающие под pattern.
    alias <what> <to>
            - Создает новый алиас. Алиасы используются следующим образом:
              начало команды, введенной пользователем, проверяется на совпадения
              с существующими алиасами. Команда считается совпавшей с алиасом,
              если эта команда начинается на <what> часть алиаса, и после нее
              идет пробельный символ. Тогда остаток команды интерпретируется как
              список аргументов алиаса, и вместо _всей_ команды подставляется
              строка <to>. Подставить в <to> аргументы можно, указав явно, \$1
              для первого аргумента, \$2 для второго и т. д. \$0 заменяется на
              все введенные аргументы. Пример:
                    alias bs bash\;stand
                    alias bst bash \$1\;stand
    unalias <pattern>
            - удаляет алиасы, соответствующие pattern.
    variable
    variable <pattern>
    variable <name> <value>
    set <name> <value>
            - создание и просмотр пользовательских переменных. К созданным
              переменным можно обращаться, указав $name.
              Замечание: <name> надо указывать без символа '$'!!! Если Вы
              напишете $name, то вместо $name будет подставлено значение
              переменной name! А соответственно, значение будет присвоено
              переменной, имя которой совпадает со значением переменной name.
              Вот как это выглядит:
                /var foo bar
                -:- {foo} is now set to {bar}.
                /set $foo hi!
                -:- {bar} is now set to {hi!}.
                /var
                -:- Defined variables:
                -:- {foo}={bar}
                -:- {bar}={hi!}
              set отличается от variable тем, что у set существует только одна
              форма (set <name> <value>), и, если <value> является
              арифметическим выражением, заключенным в круглые скобки, то <name>
              присваивается результат вычисления этого выражения. Кроме того,
              при установе значения с помощью set на экран не печатается
              подтверждение действия. Пример:
                mmc> /set a 1+2
                mmc> /set b (1+2)
                mmc> /var
                -:- Defined variables:
                -:- {a}={1+2}
                -:- {b}={3}
    unvariable <pattern>
            - удаляет переменные. Знак "$" указывать не надо! (см команду var).
    showme <список текстовых строк и переменных>
            - печатает все это пользователю на экран как сообщение клиента
              (то есть с префиксом -:- ).
    echo <список текстовых строк и переменных>
            - тоже печатает пользователю на экран, только без префикса клиента,
              но зато позволяет печатать цветные сообщения. Цвета указываются
              так: &<буква>. Например: /echo &JTHIS IS A TEST ONLY!!!
    wecho <номер окна> <список текстовых строк и переменных>
            - тоже самое, но в любое окно
    send    - посылает сообщение игровому серверу, минуя обработку алиасов.
              Переменные по-прежнему подставляются. Рекомендуется для
              использования в триггерах для предотвращения возможной подстановки
              алиасов в командах.
    ps      - печатает список выполняемых асинхронных задач.
    kill [<task_id>]
            - прекращает выполнение асинхронной задачи с идентификатором
              task_id. Если <task_id> не указан, прекращает выполнение последней
              асинхронной задачи.
    char    - печатает символ, используемый для команд клиенту.
    char <строка>
            - определяет, какой префикс будет использоваться для команд клиенту.
              Пример: /char {hey, you! }
    bind    - команда bind позволяет пользователю определять "горячие кнопки",
              то есть позволяет назначить функции на нажатие клавиш
              пользователем. Без параметров она покажет определенные
              пользователем кнопки, bind -a покажет все назначенные функции,
              включая функции редактора, назначенные самим клиентом. Первым
              параметром указывается обозначение кнопки либо ее код (с 
              приставкой C- для обозначения <Ctrl> и M- для <Alt>. Например:
              /bind C-C /quit будет вызывать /quit при нажатии <Ctrl>-C).
              Если указан только один параметр, кнопка, клиент распечатает
              определенную на нее реакцию.
              Пример:
                /bind C-C /quit     - <Ctrl>-c = <Ctrl>-<Shift>-c = /quit
                /bind C-c /quit     - то же самое, регистр не важен
                /bind M-c /connect mud.arctic.org 2700      - по <Alt>-c
                /bind M-C /dc       - дисконнект по <Alt>-<Shift>-C.
                /bind 265 {recite recall}   - кнопка F1 (у меня во всяком
                    случае. См. параметр -k). Впрочем, можно сказать и
                /bind F1 {recite recall}    - тоже самое
    unbind <кнопка>
            - удалить горячую кнопку.
    bell    - бип
    cr      - послать игровому серверу пустую строку
    nop     - ничего не делает
    action  - создает триггер (см п. VI)
    substitute <regexp> <new> [<options>]
            - простой триггер, который заменяет во всех пришедших от сервера
              строках <regexp> на <new> при выводе на экран. Подробнее см.
              п. VI.
    gag <regexp> [<options>]
            - простой триггер, который при получении строки, соответствующей
              <regexp>, ничего не делает и не печатает полученную строку.
              Обычно включается для малоинформативных и мешающих сообщений,
              чтобы они не захламляли экран. Пример:
                gag {^Morgion tells you}
    xsub <regexp> <new> <command> [<options>]
            - объединяет возможности action и substitute.
    unaction <группа>
            - удалить группу триггеров
    enable <группа>
            - разрешить группу триггеров
    disable <группа>
            - запретить группу триггеров
    log [-c] [<имя файла>|off]
            - включает/выключает лог. Если лог уже был включен, старый файл с
              логом предварительно закрывается. При указании ключа -c, в лог
              будут записывать и ansi последовательности для смены цвета.
    tabadd <слово>
    tabdelete <слово>
            - добавить/удалить слово в список дополнений (см. п. IV.5).
    tablist - посмотреть список дополнений
    perl    - написать прямой вызов на перле.
    tickset - сказать клиенту, что только что наступил новый игровой час.
    ticksize <time>
            - установить размер игрового часа (в секундах. Должен быть не менее 
              20).
    tick    - показать, сколько осталось до конца игрового часа.
    tickoff - выключить таймер.
    hook    - позволяет определять триггера на некоторые специальные события, не
              более чем по одному триггеру на каждое. На данный момент такими
              событиями являются соединение с игровым сервером (connect),
              отсоединение от него (disconnect), обнаружение приглашения сервера
              (prompt) и 2 события таймера: pretick и tick.
              Пример: /hook pretick {gt TICK in 10 seconds}
              Триггеру на приглашение сервера в качестве параметра передается
              это приглашение. Если этот триггер вернет какую-то строку, эта
              строка и будет использоваться клиентом в качестве приглашения.
              Однако написать такой триггер можно только на perl. Пример
              приведен в файле sample.mmcrc.
    unhook  - отменить триггер на специальное событие.
    path <список обозначений=список направлений>
            - В speedwalk каждая буква обозначает направление. Однако на
              некоторых игровых серверах ряд направлений нельзя задать одной
              буквой. В таком случае для этих направлений нужно определить свои
              обозначения, например: /path {^,v=вверх,вниз}. И тогда, если
              клиент встретит в speedwalk символы ^ или v, он пошлет серверу 
              'вверх' или 'вниз' соответственно. Замечание: лишние пробелы, в
              том числе перед или после запятых, недопустимы.
    svar <name> <row> <width> [color]
            - добавить переменную в строку состояния. <name> - имя переменной,
              <row> - номер строки, в которую будет добавлено поле,
              <width> - сколько символов она будет занимать, color - номер цвета
              (по ansi). Если Вы потом удалите эту переменную (командой unvar),
              то она автоматически удалится и из строки состояния.
    if (условие) {then} [{else}]
            - Если условие истинно, то выполняется часть then, иначе часть else
              (если определена). Условие считается истинным, если:
                1) условие - это арифметическое выражение, содержащее только
                   цифры, переменные, операции +, -, *, /, операции сравнения и
                   скобки; и результат вычисления этого выражения не равен нулю;
                2) условие - это непустая строка.
              Замечание: Поскольку никаких ключевых слов, определяющих начало
              блоков then и else нет, блок else ищется всегда. То есть любой
              блок, идущий за блоком then, будет понят, как else. Поэтому я бы
              рекомендовал ставить пустой блок на место else, если блок else не
              нужен.
    info    - информация о трафике. Пункты Protocol in и Compression относятся к
              mccp.
    lpdelay <задержка>
            - Когда клиент получает от сервера неполную строку (то есть строку,
              не завершенную символом перевода строки), ему нужно решить,
              является ли эта строка приглашением, или же ее вторая половина
              просто еще не доставлена. Большинство серверов умеют завершать
              приглашение специальной последовательностью символов (GA, обычно
              это включается командой 'prompt ga' на сервере). Если клиент хотя
              бы один раз встречает эту последовательность, он предполагает, что
              режим GA включен, и определяет приглашения только по GA. Если же
              эта последовательность пока не встречалась, при получении неполной
              строки клиент ждет некоторое время, и если в течении этого времени
              не было получено продолжения строки, клиент считает ее
              приглашением сервера. Время ожидания можно задавать командой
              lpdelay.
    complete [word spec ...]
            - настройка контекстно-зависимого дополнения. Подробнее см. п. IX.
    uncomplete <pattern> ...
            - удалить правила для контекстно-зависимого дополнения.
    prefix [<строка>]
            - Установить префикс. В начало всех пользовательских команд,
              посылаемых игровому серверу, будет вставляться указанная строка.
              Команды, посылаемые серверу триггерами, асинхнонными потоками или
              алиасами, предваряться префиксом не будут.
    system <комманда>
            - запускает процесс на локальной машине; вывод этого процесса будет
              асинхронно печататься на экран. Пример:
                mmc> /system ping -c 3 mud.arctic.org
                PING mud.arctic.org (204.107.140.52): 56 data bytes
                64 bytes from 204.107.140.52: icmp_seq=0 ttl=244 time=190.267 ms
                64 bytes from 204.107.140.52: icmp_seq=1 ttl=244 time=187.617 ms
                64 bytes from 204.107.140.52: icmp_seq=2 ttl=244 time=190.746 ms

                --- mud.arctic.org ping statistics ---
                3 packets transmitted, 3 packets received, 0% packet loss
                round-trip min/avg/max/stddev = 187.617/189.543/190.746/1.376 ms
              Прекратить выполнение такой команды можно, например, вызвав
              программы ps и kill, или аналогичные (на UNIX). Пример:
                mmc> /system ping mud.arctic.org
                PING mud.arctic.org (204.107.140.52): 56 data bytes
                64 bytes from 204.107.140.52: icmp_seq=0 ttl=244 time=194.186 ms
                64 bytes from 204.107.140.52: icmp_seq=1 ttl=244 time=189.365 ms
                mmc> /system killall ping
                mmc> 
              Замечание: В Win* эта команда не работает.
    save <alias|var> <имя>
    nosave <alias|var> <имя>
            - по умолчанию, все определенные пользователем переменные и алиасы
              (командами /alias и /var и /set соответственно) будут сохранены
              в файл настроек при выходе из клиента. Команда nosave позволяет
              выборочно запретить сохранение некоторых переменных или алиасов.
              Команда save снова разрешит автоматическое сохранение.
    version - печатает версию клиента. Не забывайте указывать точную версию в
              bug report.
    soundevent [<event> <filename>]
            - добавить связь между событием и звуковым файлом,
              файл "beep" проигрывает стандартный звук. Команда без параметров
              показывает список установленных событий.
    playsound <event>
            - проигрывает файл, связанный с событием <event>.
            Стандартые события, используемые самим клиентом:
              Editor

            Звуковые команды пока реализованы только под Windows, под Unix
            всегда производится стандартный звук.

VI.     ТРИГГЕРЫ
    Триггер - одна из основных и чаще всего используемая возможность клиента.
Задача большинства триггеров - снять с человека необходимость выполнять рутинные
и неинтересные действия, переложив эту обязанность на самого клиента. Он никогда
не забудет выполнить эти действия, при этом выполнит эту их максимально быстро и
без ошибок (если триггер правильно написан. Неправильно написанный триггер, а
тем более, плохо продуманный или реализованный механизм триггеров в клиенте, так
же быстро убьет Вашего персонажа или сделает еще какую-нибудь пакость). Однако
этим возможности триггеров не ограничены. В идеале, Вы можете переложить на
триггеры почти все свои действия. И Вы ошибаетесь, если думаете, что сделать это
можно только в теории. В mmc возможности триггеров ограничены только Вашими
возможностями формулировать задачу. Если Вы знаете, что должен делать тот или
иной триггер, Вы можете такой триггер написать. Причем написать так, как хотите,
не борясь с синтаксисом клиента, не создавая псевдомассивы или псевдохэши и не
создавая цепочку триггеров, чтобы обойти ограничения, накладываемые клиентом.
Потому что в mmc Вы и так можете все это использовать. Потому, что в mmc Вы
можете писать триггера на языке программирования perl. И использовать все его
возможности. Язык perl создавался преимущественно для обработки текста, и имеет
все необходимое для эффективной работы с ним. В том числе встроенные массивы,
хэши, множество встроенных функций, и главное, наиболее мощные регулярные
выражения, с помощью которых можно легко писать шаблоны для строк и извлекать из
этих строк любую информацию. Вам совсем не обязательно знать perl для написания
триггеров. Вы можете создавать триггеры просто командой action, и при этом Вы
по-прежнему имеете возможность использовать регулярные выражения. Или писать
триггеры по приведенным ниже примерам. 95% триггеров можно написать, вообще не
зная perl'а. Все зависит от сложности поставленной задачи и Вашего желания ее
решить.
    Поскольку написание любого триггера в mmc требует знаний, что такое
регулярное выражение, я кратко опишу основные возможности и правила их
написания. Для получения более полной информации о регулярных выражениях я
рекомендую почитать файл perlre из документации perl (41k текста, прилагается). 

    Регулярное выражение - это образец. Считается, что вся строка удовлетворяет
регулярному выражению, если хотя бы одна подстрока этой строки соответствует
регулярному выражению (как проверить совпадение всей строки, будет сказано
ниже).
    Одни части регулярного выражения обозначают отдельные символы, другие части
соответствуют группам символов. Сначала мы рассмотрим образцы, соответствующие
одному символу, а затем образцы, при помощи которых в регулярном выражении
обозначается группа символов.
    Самый простой и самый распространенный символ, встречающийся в регулярных
выражениях, - это одиночный символ, соответствующий самому себе. Другими
словами, наличие буквы а в регулярном выражении требует наличия соответствующей
буквы а в строке. Следующий из распространенных символов сопоставления - точка
('.'). Точке соответствует любой одиночный символ. Например, образцу "а."
соответствует любая двухбуквенная последовательность, которая начинается с буквы
а. Если регулярное выражение содержит список символов, заключенных в квадратные
скобки ([]), то такому выражению соответствует один любой символ из этого
списка. Например, образцу [abcde] соответствуют любая буква из первых пяти
строчных букв английского алфавита, а образцу [yY] соответствуют буквы 'y' и
'Y'. Если вы хотите вставить в список правую квадратную скобку (]), поставьте
перед ней символ '\' или же поставьте эту скобку на первое место в списке.
Диапазоны символов (например, от а до z) можно задавать, указав конечные точки
диапазона через дефис (-). Чтобы включить в список дефис как символ, поставьте
перед ним символ '\' или поместите его в конец. Несколько примеров:
    [0123456789]  - обозначает любую цифру
    [0-9]         - то же самое
    [0-9\-]       - обозначает цифру или знак минус
    [a-z0-9]      - обозначает любую строчную букву или цифру
    [a-zA-ZO-9_]  - обозначает любую букву, цифру или знак подчеркивания
Если Вы хотите написать регулярное выражение, соответствующее любым символам,
кроме символов из списка, нужно указать эти символы внутри квадратных скобок,
поставив сразу же за левой скобкой знак '^'. Например: [^0-9] обозначает любой
нецифровой символ, а [^\^] обозначает любой символ, кроме символа '^'.
    Для удобства в языке perl предопределены некоторые распространенные классы
символов:
    Обозначение  Эквивалентный класс    Комментарий
    \d              [0-9]               цифра
    \w              [a-zA-ZO-9]         обычный символ
    \s              [ \r\t\n\f]         пробельный символ
    \D              [^0-9]              нецифровые символы
    \W              [^a-zA-ZO-9]        специальные символы
    \S              [^ \r\t\n\f]        непробельный символ
Приведенные выше конструкции можно использовать при задании других классов
символов, например [\da-fA-F] соответствует одной шестнадцатеричной цифре.
    Для обозначения нескольких идущих подряд символов эти символы надо просто
указать в требуемом порядке. Например, выражение abc соответствует букве а, за
которой следует буква b, за которой идет буква с. Множество любой длины (в том
числе и нулевой) идущих подряд одинаковых символов обозначается требуемым
символом, за которым следует символ '*'. Например, выражению a* соответствуют
строки "a", "aaaa" и пустая строка. Если совпадение с пустой строкой Вас не
устраивает, вместо символа '*' надо указать символ '+'. Другими словами,
выражение aa* по-другому можно записать как a+.
    Вопросительный знак (?) обозначает ни одного или один экземпляр стоящего
непосредственно перед ним символа. Например, выражение l?u+ser обозначает один
или ни одного символа l, за которым следует один или более символов u, а затем
последовательность символов ser.
    Символы *, + и ? называются множителями.
    Если нам нужно указать, скажем, от пяти до десяти символов х, можно
поставить пять иксов, а затем еще пять, поставив после каждого из последних
пяти вопросительный знак. Но в perl'е есть более простой способ - применение
общего множителя. Общий множитель состоит из пары фигурных скобок, между
которыми заключены одно-два числа, например х{5,10}. Это означает, что
необходимо найти символ, стоящий перед скобками (в данном случае это буква х),
повторяющийся указанное число раз (в рассматриваемом случае - от пяти до
десяти). Если второе число не указано (например, х{5,}), это означает "столько
или больше" (в данном случае пять и более), а если выпущена и запятая (например,
х{5}), это означает "ровно столько" (в данном случае пять символов х). Чтобы
получить пять или менее символов х, нужно перед запятой поставить нуль: х {0,5}.
Надо отметить, что выражения, содержащие множители являются "жадными", то есть
если такому выражению может соответствовать несколько символов, то каждый раз
множитель будет выбирать максимальную строку. Например, при сопоставлении строки
"greeeeeedy" с выражением [egr]*, этому выражению всегда будет соответствовать
следующая часть строки: "greeeeee". Если в одном выражении используются два
множителя, то левый множитель являются более "жадным". Например, при
сопоставлении строки "а ххх с хххххххх с ххх d" с выражением a.*c.*d, первая
комбинация ".*" в регулярном выражении соответствует всем символам до второй
буквы с, несмотря на то, что положительный результат был бы достигнут даже при
совпадении только символов, стоящих до первой буквы с. Но можно заставить любой
множитель перестать быть "жадным" (т.е. сделать его ленивым), поставив после
него вопросительный знак: a.*?c.*d. Теперь а.*? с соответствует минимальному
числу символов между а и с, а не максимальному. Это значит, что с образцом
совпадает часть строки до первой буквы с, а не до второй. Модификатор '?' можно
ставить после любого множителя (?, +, * и {m,n}).
    Стоит отметить еще одно замечательное свойство регулярных выражений:
автоматический поиск с возвратом. Например, что произойдет, если мы будем
сопоставлять строку "а ххх се хххххххх ci xxx d" с выражением 'a.*ce.*d'?
Символы .* в на первом этапе будут сопоставлены максимально возможному числу
символов, стоящих до следующей буквы с, то есть выражению a.*c будет
сопоставлена подстрока "а ххх се хххххххх c". Но очередной символ регулярного
выражения (е) не совпадает с очередным символом строки (i). В этом случае поиск
начинается сначала и завершается остановкой в некоторой позиции до выбранной на
первом этапе (в нашем случае - в позиции предыдущей с, рядом с е), то есть на
этот раз выражению a.*c будет сопоставлена подстрока "а ххх с". Теперь очередной
символ регулярного выражения (е) совпадает с очередным символом строки, и
сопоставление будет продолжено. Символу 'e' регулярного выражения будет
сопоставлен символ 'e' нашей строки, а выражению .*d - весь остаток строки.
Сложное регулярное выражение может включать множество уровней поиска с
возвратом, в результате чего время выполнения сопоставления может оказаться
достаточно большим.
    Следующая групповая операция - пара круглых скобок, в которую заключается
часть образца. При совпадении с образцом никаких изменений не происходит,
просто совпавшая часть строки запоминается, и к ней можно впоследствии
обращаться. Например, (а) продолжает соответствовать букве а, а ([a-z]) - любой
строчной букве. Чтобы использовать в выражении часть строки, которую программа
запомнила, нужно поставить символ '\' и целое число. Образец такой конструкции
обозначает последовательность символов, обозначенную ранее в паре круглых скобок
под тем же номером (считая с единицы). Например, fred(.)barney\1 соответствует
строке, состоящей из слова fred, любого символа, слова barney и еще одного
такого же символа. Таким образом, данному образцу соответствует
последовательность символов fredxbarneyx, a не fredxbarneyy. \1 обозначает
первую заключенную в круглые скобки часть регулярного выражения. Если таких
частей больше, чем одна, то вторая часть (считая левые круглые скобки слева
направо) обозначается как \2, третья - как \3 и т. д. Например, a(.)b(.)c\2d\1
обозначает а, какой-то символ (назовем его #1), b, еще один символ (назовем его
#2), с, символ #2, d и символ #1. Таким образом, этот образец соответствует,
например, строке axbycydx. Узнать последовательности, сопоставленные выражениям
в скобках, можно и вне регулярного выражения. При сопоставлении строки образцу
perl копирует цепочки, сопоставленные выражениям в скобках, в специальные
доступные только для чтения переменные. Такие переменные обозначаются как
$<цифра>, где <цифра> - это порядковый номер пары скобок в регулярном выражении.
Эти переменные можно затем использовать при определении реакции в триггерах.
    Запоминаемая часть может состоять не только из одного символа. Например,
а(.*)Ь\1с обозначает а, любое количество символов (даже нуль), b, ту же
последовательность символов и, наконец, с. Следовательно, этот образец совпадет
со строкой aFREDbFREDc и со строкой abc, но не со строкой аХХЬХХХс.
    Следующая групповая конструкция - дизъюнкция, т.е. а|b|с. Это значит, что
данный образец соответствует только одному из указанных вариантов (в данном
случае - а, b или с). Такая конструкция работает даже в том случае, если
варианты содержат несколько символов, как в образце /me|you/, что соответствует
либо me, либо you.
    Кроме уже перечисленных образцов, в языке perl есть еще несколько
предопределенных образцов, которым соответствуют подстроки нулевой длины, но
стоящие на определенных местах. Такими образцами являются ^, $, \b, \B и еще
некоторые, о которых можно почитать в файле perlre.txt.
    Символы ^ и $ обозначают начало и конец строки соответственно. Образец \b
требует, чтобы совпадение происходило только на границе слова, а образец \B -
чтобы совпадение происходило только внутри слова. Граница слова - это место
между символами, один из которых соответствует классу \w, а второй - классу \W,
а также начало или окончание строки. Например, образцу .*\B[a-z]$ соответствуют
строки "aaab" и "adc dx", но не "axxB" или "adcd x".
    И отдельно следует сказать о символе '\'. Этот символ используется для
представления непечатных и специальных символов, таких как символ табуляции
(\t), перевод строки (\n), символов квотирования и функций изменения регистра
(\Q, \l, \u, \L, \U, \E), о действии которых можно почитать в perlre.txt. Кроме
того, с помощью символа '\' можно запретить интерпретацию специальных символов,
таких как *, ?, +, [, ., ^, $, |, ( и, конечно, самого символа '\'. Для этого
перед специальным символом надо поставить символ '\', вот так: .*\.txt.
    Для определения порядка применения образцов в регулярных выражениях, всем
образцам присвоен приоритет. Приоритет образцов (от высшего к низшему) таков:
    Наименование                    Обозначение
    Квадратные скобки, группировка  []
    Круглые скобки                  ( ) (?: )
    Множители                       ? + * {m,n} ?? +? *? {m,n}?
    Последовательность и позиция    abc ^ $
    Дизъюнкция                      a|b|c
    Если Вас не устраивает приоритет, Вы можете явно указать порядок применения
образцов, расставив в регулярном выражении круглые скобки. Однако изменение
приоритета с помощью круглых скобок одновременно активизирует режим запоминания
для данного образца. То есть эти круглые скобки учитываются, когда определяется,
соответствует ли какой-то элемент \2, \3 и т.д. Если вы хотите использовать
круглые скобки без включения режима запоминания, применяйте форму (?:...), а не
(...). Она тоже позволяет указывать множители, но не изменяет значение счетчика
подлежащих запоминанию цепочек.

    Триггер создается следующим образом: action <regexp> <command> [<options>]
Для всех строк, совпадающих с <regexp>, вызывается <command>. <command>
интерпретируется просто как пользовательский ввод, то есть в <command> ищутся
алиасы и команды, а если <command> не соответствует ни тому, ни другому, текст
<command> просто посылается игровому серверу. Это позволяет легко писать
адаптивные триггеры, например: 
    /action {^You receive [0-9]+ experience\.$} {loot corpse}
И теперь действие триггера будет определяться алиасом на loot. Возможные алиасы
такие:
    /alias loot exa {$0}                - только посмотреть, что там
    /alias loot get pile {$0}           - взять только деньги
    /alias loot get all {$0}            - взять все
    Иногда обработка алиасов может быть неудобной. Если обработка алиасов Вас
не устраивает, используйте команду send. 
    Замечание: все команды action, substitute, gag и xsub имеют одинаковый
формат регулярного выражения, команды и настроек. Поэтому все, что сказано
об action, относится и к substitute, и к gag, и к xsub.
    Для более точной настройки для каждого триггера хранится список тонких
настроек, который можно указать в <options> при создании триггера. Формат
указания настроек такой:
<список флагов>[:<список групп через запятую>]. Возможные флаги:
    '-'     - disable       - запретить применение этого триггера (по умолчанию
                              все триггеры создаются активными)
    'g'     - gag           - клиент не должен печатать совпавшую строку
    'm'     - multiple      - ищутся все вхождения <regexp> в строке, а не
                              только первое
    <число> - priority      - приоритет, определяющий порядок применения
                              триггеров. Триггеры применяются в порядке
                              уменьшения приоритетов. По умолчанию у всех
                              триггеров приоритет равен 1000.
    's'|'n' - save|nosave   - сохранять ли триггер в файл конфигурации при
                              выходе
    'f'     - fall-through  - обычно клиент прекращает поиск триггеров, после
                              первого совпадения. Если необходимо применять
                              другие триггеры после этого, при его определении
                              необходимо указать флаг 'f'.
    'x<число>'              - максимальное число срабатываний, после которого
                              триггер автоматически отключатся, по умолчанию не
                              ограничено, счетчик сбрасывается по команде
                              /enable
    Пример простого триггера:
        action {^You are hungry\.$} {get bread $container;eat bread} 1000gs:CORE
    Триггеры рекомендуется группировать в соответствии с назначением. Клиент
умеет запрещать или удалять группы триггеров, и продуманная группировка
триггеров не только позволит легко управлять действиями клиента, но и
гарантирует, что Вы не забудете разрешить или отменить какой-нибудь триггер для
сложных действий, требующих несколько триггеров.

VII.    SPEEDWALK И АСИНХРОННЫЕ ПОТОКИ ВЫВОДА
    Иногда удобно, чтобы клиент время от времени самостоятельно посылал игровому
серверу какие-то команды. Например, чтобы клиент раз в 10 минут посылал серверу
команду sneak. Такую возможность я буду называть "асинхронным потоком вывода".
    В mmc пользователь имеет 3 различные возможности создать асинхронный поток
вывода, но одна из них доступна только как вызов на perl'е.
    Первый способ - команда вида /<repeat>[:<delay>] <command>. Она заставляет
клиент выполнить команду <command> <repeat> раз с периодичностью <delay>
милисекунд. Если <delay> не указан, команда выполняется указанное число раз без
задержек. Пример:
    /5:300 say I rule
Замечание: указать можно любую, но только одну команду. Если Вы хотите указать
две команды, то Вам необходимо либо запустить 2 асинхронных потока вывода, либо
создать алиас и указать в его в качестве команды.
    Второй способ - это задать speedwalk. Speedwalk - это компактно записанный
путь в виде последовательности направлений, например dnws2e. В mmc speedwalk
начинается с точки или двух точек, за которыми указан путь. Если speedwalk
начинается с точки, то клиент разбивает его на буквы, заменяет буквы на
направления в соответствии с имеющимися правилами (см. команду path), и посылает
их серверу. Если speedwalk начинается с двух точек, клиент посылает серверу
обращенный speedwalk. Другими словами, если по speedwalk'у .dnwsee серверу будет
послано:
    d
    n
    w
    s
    e
    e
то по speedwalk'у ..ndws2e серверу будет послан обратный путь:
    w
    w
    n
    e
    s
    u
При этом speedwalk посылается серверу постепенно, по 5 комнат каждые 500
милисекунд. Это позволяет Вам вовремя предпринять какие-то действия, если,
например, на Вас напали по дороге.
    Третий способ, функция timeout, будет описан в п. VIII.

VIII.   ФАЙЛ ИНИЦИАЛИЗАЦИИ
    При каждом запуске клиент пытается сначала прочитать файл начальных
пользовательских настроек, .mmc4rc. При этом, если переменная окружения $MMC
установлена, клиент предполагает, что этот файл находится в каталоге $MMC,
если переменная $MMC не определена, файл берется из $HOME, а если и эта
переменная не определена, файл ищется в текущем каталоге. При выходе клиент
обновляет этот файл в соответствии с изменениями настроек, сделанными
пользователем.
    Файл инициализации состоит из двух разделов. Первый раздел - это функции,
написанные на языке perl. Этот раздел создается и изменяется только
пользователем. В нем пользователь может определять свои триггеры, алиасы,
создавать новые команды клиенту и делать много чего еще. Начинается этот раздел
с первой строки файла инициализации, а заканчивается строкой "__DATA__". При
запуске клиент просто исполняет этот раздел, а при выходе - оставляет без
изменений.
    Второй раздел начинается со строки "__DATA__" и используется клиентом для
сохранения настроек, которые пользователь сделал из самого клиента. В принципе,
Вам не обязательно редактировать этот раздел (кроме секций [run] и [complete]),
но если очень хочется, то можно.
    Этот раздел состоит из нескольких секций. Каждая секция начинается c
названия секции, заключенной в квадратные скобки. Секции могут быть указаны в
произвольном порядке. При сохранении файла клиент снова сохранит эти секции в
том же порядке, в котором они были указаны. Если клиент не встретит какой-то
секции, он создаст ее в конце файла. Замечание: алиасы и триггеры, созданные из
perl (в первом разделе файла инициализации или с помощью команды /perl), не
сохраняются в секциях второго раздела.
    Особый интерес представляет секция [run]. Как только клиент встречает эту
секцию, он исполняет указанные в ней команды. А поскольку клиент помнит порядок
секций при сохранении, Вы можете, например, инициализировать переменные при
загрузке клиента. Пример:
        [vars]
        Loot    2
        ...
        [run]
        /if (Loot==0) {/set Loot 1}
    Секция [complete] имеет одну особенность: если клиент встречает эту секцию в
файле инициализации, он НЕ устанавливает команд дополнения по-умолчанию.  Так
что если Вы решили добавить эту секцию в файл инициализации, перенесите в нее
нужные Вам дополнения сами. Сам клиент этой секции, как и секции [run], не
создает.
    Как следует из всего вышесказанного, редактирование пользователем файла
инициализации нужно преимущественно для написания команд на perl'е. Для этого
пользователю желательно (хотя и не обязательно) знать язык perl, а так же
внутренний программный интерфейс клиента. Ниже я вкратце опишу основные функции
программного интерфейса. Примеры их использования можно посмотреть в прилагаемом
файле sample.mmcrc. Для большинства пользователей, даже не знакомых с perl,
будет достаточно просто посмотреть на примеры и писать по аналогии.

Mmc - клиент для игры в mud, но его можно использвать и для других целей.
Поэтому используемый мною термин "строка из mud'а" на самом деле следует
понимать как "строка, полученная mmc из сокета", или даже "строка, полученная
mmc из некоторого источника, принадлежащего классу CL::Socket". С помощью
легкой правки можно обучить mmc открывать не только telnet сессии, но и
локальные файлы или даже использовать в качестве источника output некоторой
программы.  Страждущим могу порекомендовать немного помедитировать над CL.pm в
разделе package CL::Socket. Кроме того, простенький примерчик я приведу в конце
этого файла.

1. Итак, собственно MMC API:
    echo($message)
    - сообщение пользователю на экран в основное (1е) окно. Цвета в
      строке переключаются последовательностями "\003<буква>". Список
      стандартных ANSI цветов:

    Черный                    \003A
    Красный                   \003B
    Зеленый                   \003C
    Коричневый                \003D
    Синий                     \003E
    Малиновый                 \003F
    Голубой                   \003G
    Светло-серый (основной)   \003H
    Серый                     \003I
    Ярко-красный              \003J
    Салатовый                 \003K
    Желтый                    \003L
    Светло-синий              \003M
    Розовый                   \003N
    Светло-голубой            \003O
    Белый                     \003P
    В win* версии для обозначения 256 цветов используется весь диапазон
    char.


    wecho($window, $message)
      аналогично echo, выводит сообщение в окно $window. Окна нумеруются
      с 1 до 10. Сам mmc всегда печатает в окно 1. Единственные способ
      печатать в другие окна - делать это самому, используя w* команды.
    
    printc(@lines)
      соединяет массив строк в одну и печатает получившуюся строку в
      основное (1е) окно. Обозначение цветов - "&<буква>", буквы как и в
      echo. Чтобы вставить в строку символ '&', его надо указать 2 раза:
      "&&". Нафига надо обозначать цвета через & - не очень понятно.
      Впрочем, цвета в формате "\003<буква>" работать будут :)

    wprintc($window, @lines)
      я думаю, понятно :)

    msg(@lines)
      выводит @lines пользователю в основное (1е) окно с тем же префиксом,
      что и сообщения самого mmc.

    trig(&code, $line; $flags)
      добавить триггер. &code - функция-обработчик, $line - строка, на
      которую триггер настроен, $flags - необязательный пареметр, список
      флагов триггера. Флаги подробно расписаны в README.
      Функции-обработчику передаются запрошенные совпадения ($1-$9) и
      пришедшая от сервера строка, на которую этот триггер настроен. (На
      самом деле триггеру передаются 2 строки: $_ - это строка без
      цветов, и $; - строка с цветами во внутреннем формате mmc.)
      Триггер МОЖЕТ изменять эти строки, но если он это делает, он
      должен сам следить за соответствием строк $_ и $; примеры
      использования можно посмотреть в sample.mmcrc

    subst($what, $to; $flags)
      вариант триггера, заменяющий пришедшую из mud'а строку $what на
      строку $to. $flags - необязательный пареметр, список флагов
      триггера.

    gag($what; $flags)
      вариант триггера subst, практически subst($what, undef, "g$flags");
    
    xsub(&code, $what, $to; $flags)
      самый полный вариант триггера. trig и subst в одном флаконе.
      Сначала выполнится замена, а потом будет вызван &code.
    
    enable(@group_list)
      разрешает срабатывание триггеров из перечисленных групп

    disable(@group_list)
      запрещает срабатывание триггеров из перечисленных групп

    alias(&code, $command)
      добавить алиас. Если пользовательский ввод начинается с команды
      $command, будет вызвана функция &code. Остаток пользовательского
      ввода будет разбит на слова и они будут переданы функции &code в
      виде массива аргументов.

    bindkey(&code, $hotkey)
      добавить обработку hotkey. При получении последовательности hotkey
      будет выполнена функция &code. Как указывается hotkey рассказано в
      README.

    hook(&code, $event)
      вызов &code при наступлении одного из специальных событий. Такими
      событиями являются connect, disconnect, prompt (получение
      приглашения от mud'а), input, send, pretick и tick. prompt hook в
      качестве параметра получает то, что клиент определил, как
      приглашение mud server'а. input вызывается в момент, когда
      пользователь нажал enter. &code получает аргументов введенную
      строку так, как ее ввел пользователь. send вызывается в момент
      посылки строки в socket, получая копию посылаемой туда строки.
      Остальные hook'и параметров не получают.

    sendl($)
      послать в mud строку.
    
    timeout(&code, $delay; $count)
      каждые $delay миллисекунд будет вызваться &code до тех пор, пока
      число вызовов не превысит $count. Если $count не указан, &code
      будет вызываться неограниченное (почти ;) число раз.

    nosave(@)
      список переменных пакета U:: (пользовательские переменные),
      которые не надо сохранять при выходе из mmc (а соответственно, не
      надо восстанавливать при его новом запуске).

    new_sv(\$var, $width; $color)
      добавить переменную в строку состояния. $width - сколько символов
      зарезервировать в status line для переменной. Если $width=0, то
      для переменной будет выделено все свободное место (а
      соответственно, все переменные, указанные после нее, будут
      прижиматься к правому краю экрана). $color необязателен. При
      изменении значения $var строка состояния обновляется
      автоматически.

    new_svy(\$var, $width, $row; $color)
       для многострочных сток состояния, $row - номер строки, в которой
       надо расположить переменную.



  Пример соединения с другими хостами.

    package RTime;
    # read date string from a remote machine

    use base 'CL::Socket';

    sub line($$) {
      CL::msg("Current time is: " . CL::strip_colors($_[1]));
    }

    sub CMD::cmd_gettime {
      if ($#_<0) {
        CL::warn("gettime: usage: /gettime <host>");
      } else {
        new RTime($_[0],13);
      }
    }

    1;

    Примеры использования этих функций можно посмотреть в файле sample.mmcrc.
Это - полностью законченный файл инициализации для игры магом в arctic mud
(mud.arctic.org 2700). Если Вы играете другим классом или в другой mud, вам
придется этот файл немного поправить. Одно замечание: все, что стоит после
символа #, является комментарием.

IX.     КОНТЕКСТНО-ЗАВИСИМЫЕ ДОПОЛНЕНИЯ
    Поскольку mud - это игра в реальном времени, очень много зависит от скорости
набора команд пользователем. Для облегчения набора команд и уменьшения
количества опечаток, в mmc, кроме дополнения строк и слов по истории
пользовательского ввода, имеется возможность задавать правила для контекстно-
зависимого дополнения по словам.
    Формат этих правил очень похож на формат правил дополнения командного
интерпретатора tcsh. Общий вид правил:
    /complete regexp0 spec/regexp1/list[:select]/[suffix] [spec/regexp2/list[:select]/[suffix]] ...
    Схема работы автодополнения такова: если пользователь нажал кнопку <Tab>,
клиент выделяет команду, в которой находился курсор, и, просматривая подряд
список определенных дополнений, находит правило, regexp0 которого удовлетворяет
ВСЕЙ введенной пользователем команды (при этом все символы строки, находящиеся
после текущей позиции курсора, игнорируются). Найденное правило будет
использоваться для дополнения. Дальнейший поиск среди правил дополнения не
производится.
    После того, как правило выбрано, клиент пытается дополнить текущее слово
(то есть слово, в конце которого стоит курсор. А поскольку все символы после
текущей позиции курсора игнорируются, то получается, что курсор всегда стоит в
конце слова. Правда, иногда текущее слово может быть пустым) в соответствии с
этим правилом. Сначала клиент определяет, на основании чего будет производиться
дополнение. В правиле на это указывает поле spec. Spec - это всегда ОДНА буква;
возможые буквы такие: p,c,n,N. В зависимости от поля spec определяется
интерпретация второго поля правила. p - это позиционное дополнение, то есть
дополнение в зависимости от порядкового номера слова в строке. В качестве
regexp1 тогда указывается диапазон возможных позиций слова при дополнении.
c - дополнение на основании текущего слова. То есть текущее слово дополняется,
если его начало удовлетворяет regexp1. regexp1 тогда - обычный perl regexp.
n - дополнение на основании предыдущего слова. То есть текущее слово
дополняется, если предыдущее слово удовлетворяет regexp1. regexp1 - perl regexp.
N - дополнение на основании слова, стоящего за слово до текущего. Остальное все
как для n.
    Если условие regexp1 не выполнено, то клиент пытается применить следующее
правило в строке (то есть spec/regexp2), если оно указано. Если ни одно правило
не применимо, никакого дополнения не производится.
    Как только клиент нашел правило, удовлетворяющее перечисленным условиям, он
строит список возможных дополнений. Список строится так: берется list (это может
быть список вида '(a b c d)', переменная, либо один из предопределенных списков.
Предопределенные списки такие:  a - список всех определенных алиасов,
                                v - список всех определенных переменных,
                                p - список идентификаторов выполняемых задач,
                                c - список определенных команд,
                                t - список имен групп триггеров,
                                h - определенные специальные триггера (хуки),
                                H - все специальные триггера,
                                u - список, созданный с помощью tabadd.
    Из списка берутся все слова, удовлетворяющие условию select (если оно не
указано, берутся все слова из list. select - это регулярное выражение), из
полученного списка берутся слова, начинающиеся на введенное пользователем
начало слова, и вместо введенного начала слова подставляется первое слово из
полученного списка, сразу за которым подставляется suffix (если определен). При
повторном нажатии на <Tab> будет подставлено следующее слово из списка, за
которым опять будет добавлен suffix, и так до тех пор, пока не кончится список.
Если список кончился, а пользователь снова нажал <Tab>, клиент подставит
обратно введенный пользователем префикс и издаст звуковой сигнал. Если
пользователь снова нажмет <Tab>, клиент снова начнет подставлять слова из
построенного списка.
    Замечание: При поиске подходящего правила дополнения клиент сначала
просматривает список правил сверху вниз, до первого соответствия шаблону
regexp0. Как только соответствие найдено, клиент начинает просматривать для
этой строки шаблоны слева направо. Как только найдено соответствие паре
spec/regexp1, клиент строит список возможных дополнений. Клиент уже больше не
вернется к поиску среди шаблонов или строк, даже если дальше тоже возможны
совпадения. Просмотр списка строк не будет продолжен даже если ни одна из пар
spec/regexp не применима.

X.      ВНУТРЕННОСТИ КЛИЕНТА
    Хотя весь клиент состоит из одного файла, внутри него находится множество
модулей, написанных на языке perl. Одной из замечательных особенностей клиента
является то, что при загрузке этих модулей он сначала ищет их в текущем каталоге
(точнее, по всем каталогам, указанным в @INC), и лишь если не находит модуля
там, использует встроенный. Поэтому Вы можете легко изменять поведение клиента,
даже не пересобирая его. Для этого достаточно просто подложить соответствующий
файл в текущий каталог, и mmc подцепит его при загрузке (либо положить этот файл
в любой другой каталог и указать '-i <путь до этого каталога>' при запуске
клиента).
    Наиболее интересным является модуль Conf, который находится в файле Conf.pm.
В нем хранятся некоторые настройки клиента. Пока этот файл выглядит так:
=== Начало файла Conf.pm ===
    package Conf;

    # Configuration defaults

    $Conf::char='/';        # command char, don't forget to update
                            # Parser::cmdre if you change this at runtime
    $Conf::sep=';';         # Command separator, cannot be changed at runtime
    $Conf::defprompt="\003Cmmc> ";  # default prompt when the client is not
                            # connected to a server
    $Conf::incolor=11;      # user input color, be sure to call
                            # CL::set_iattr() if you change this at runtime
    $Conf::iccolor=15;      # control chars color
    $Conf::icbg=1;          # control chars background
    $Conf::statusbg=4;      # status line background
    $Conf::statusfg=2;      # status line default foreground
    $Conf::send_verbose=1;  # display all text that gets sent to the server
    $Conf::verbose=1;       # display various sucky messages
    $Conf::status_type=2;   # status line position
    $Conf::status_height=1; # status line height
    $Conf::save_stuff=1;    # automatically save triggers, aliases, keybindings,
                            # variables
    $Conf::speedwalk_delay=500; # delay after sending 5 rooms
    $Conf::logsub=1;        # log lines _after_ substs take place

    1;
=== окончание файла Conf.pm ===
Если Вы подсунете клиенту этот файл, Вы легко сможете изменять перечисленные в
нем установки клиента, в том числе и параметры, недоступные из командного
интерфейса. Например, если Вы хотите, чтобы пользовательский ввод печатался
салатовым цветом, поставте $Conf::incolor=10. Если установить Conf::send_verbose
в 0, то клиент не будет печатать строки, посылаемые серверу по горячим кнопкам,
а если установить $Conf::verbose в 0, то клиент не будет печатать подтвердения
при определении переменных по команде var, определении триггеров и алиасов и ряд
других подтверждений.

XI.     ИЗВЕСТНЫЕ ГЛЮКИ

 $Id: mmc.txt,v 1.8 2001/07/17 12:34:27 mike Exp $

